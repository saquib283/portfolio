{"version":3,"sources":["../../../../src/components/FocusModeOverlay.tsx","../../../../node_modules/framer-motion/src/render/dom/scroll/offsets/edge.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/offsets/presets.ts","../../../../node_modules/motion-dom/src/resize/handle-window.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/offsets/offset.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/offsets/inset.ts","../../../../node_modules/motion-dom/src/scroll/observe.ts","../../../../node_modules/motion-dom/src/resize/index.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/utils/get-timeline.ts","../../../../node_modules/motion-dom/src/resize/handle-element.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/attach-animation.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/index.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/on-scroll-handler.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/info.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/track.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/offsets/index.ts","../../../../node_modules/framer-motion/src/render/dom/scroll/attach-function.ts","../../../../node_modules/lucide-react/src/icons/maximize-2.ts","../../../../node_modules/framer-motion/src/value/use-scroll.ts"],"sourcesContent":["\"use client\";\r\n\r\nimport { motion, AnimatePresence, useScroll, useSpring } from 'framer-motion';\r\nimport { Maximize2, Minimize2, X } from 'lucide-react';\r\nimport { useState, useEffect } from 'react';\r\n\r\nexport default function FocusModeOverlay({ children, title }: { children: React.ReactNode, title: string }) {\r\n    const [isFocused, setIsFocused] = useState(false);\r\n    const { scrollYProgress } = useScroll();\r\n    const scaleX = useSpring(scrollYProgress, {\r\n        stiffness: 100,\r\n        damping: 30,\r\n        restDelta: 0.001\r\n    });\r\n\r\n    useEffect(() => {\r\n        if (isFocused) {\r\n            document.body.style.overflow = 'hidden';\r\n        } else {\r\n            document.body.style.overflow = 'unset';\r\n        }\r\n        return () => {\r\n            document.body.style.overflow = 'unset';\r\n        };\r\n    }, [isFocused]);\r\n\r\n    return (\r\n        <>\r\n            <button\r\n                onClick={() => setIsFocused(true)}\r\n                className=\"fixed bottom-10 right-10 z-40 p-4 bg-accent text-black rounded-full shadow-2xl hover:scale-110 active:scale-95 transition-all group flex items-center gap-2 pr-6\"\r\n            >\r\n                <Maximize2 size={20} />\r\n                <span className=\"text-sm font-bold uppercase tracking-widest overflow-hidden max-w-0 group-hover:max-w-[100px] transition-all\">Enter Focus</span>\r\n            </button>\r\n\r\n            <AnimatePresence>\r\n                {isFocused && (\r\n                    <motion.div\r\n                        initial={{ opacity: 0 }}\r\n                        animate={{ opacity: 1 }}\r\n                        exit={{ opacity: 0 }}\r\n                        className=\"fixed inset-0 z-[100] bg-background flex flex-col items-center overflow-y-auto pt-24 pb-32 px-6 no-scrollbar\"\r\n                    >\r\n                        {/* Progress Bar */}\r\n                        <motion.div\r\n                            className=\"fixed top-0 left-0 right-0 h-1.5 bg-accent origin-left z-[110]\"\r\n                            style={{ scaleX }}\r\n                        />\r\n\r\n                        {/* Top Controls */}\r\n                        <div className=\"fixed top-0 left-0 right-0 p-8 flex justify-between items-center z-[110] bg-gradient-to-b from-background to-transparent\">\r\n                            <div className=\"flex flex-col\">\r\n                                <span className=\"text-[10px] uppercase tracking-[0.3em] text-secondary/40 font-bold mb-1\">Focus Mode</span>\r\n                                <span className=\"text-sm font-bold text-primary\">{title}</span>\r\n                            </div>\r\n                            <button\r\n                                onClick={() => setIsFocused(false)}\r\n                                className=\"p-3 bg-surface border border-border rounded-xl text-primary hover:bg-red-500 hover:text-white transition-all shadow-xl\"\r\n                            >\r\n                                <X size={20} />\r\n                            </button>\r\n                        </div>\r\n\r\n                        {/* Immersive Content */}\r\n                        <motion.div\r\n                            initial={{ y: 50, opacity: 0 }}\r\n                            animate={{ y: 0, opacity: 1 }}\r\n                            transition={{ delay: 0.2 }}\r\n                            className=\"max-w-3xl w-full\"\r\n                        >\r\n                            <div className=\"prose prose-2xl dark:prose-invert prose-headings:font-display prose-headings:font-bold prose-p:text-secondary prose-p:leading-relaxed prose-img:rounded-3xl prose-a:text-accent selection:bg-accent selection:text-white\">\r\n                                {children}\r\n                            </div>\r\n                        </motion.div>\r\n\r\n                        {/* Bottom Indicator */}\r\n                        <div className=\"fixed bottom-0 left-0 right-0 p-8 text-center pointer-events-none bg-gradient-to-t from-background to-transparent\">\r\n                            <span className=\"text-[10px] uppercase tracking-[0.5em] text-secondary/20\">Scroll to Immersion</span>\r\n                        </div>\r\n                    </motion.div>\r\n                )}\r\n            </AnimatePresence>\r\n        </>\r\n    );\r\n}\r\n","import { Edge, NamedEdges } from \"../types\"\n\nexport const namedEdges: Record<NamedEdges, number> = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n}\n\nexport function resolveEdge(edge: Edge, length: number, inset = 0) {\n    let delta = 0\n\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (edge in namedEdges) {\n        edge = namedEdges[edge as NamedEdges]\n    }\n\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge)\n\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber\n        } else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100\n        } else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth\n        } else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight\n        } else {\n            edge = asNumber\n        }\n    }\n\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge\n    }\n\n    return inset + delta\n}\n","import { ProgressIntersection } from \"../types\"\n\nexport const ScrollOffset: Record<string, ProgressIntersection[]> = {\n  Enter: [\n    [0, 1],\n    [1, 1],\n  ],\n  Exit: [\n    [0, 0],\n    [1, 0],\n  ],\n  Any: [\n    [1, 0],\n    [0, 1],\n  ],\n  All: [\n    [0, 0],\n    [1, 1],\n  ],\n}\n","import { WindowResizeHandler } from \"./types\"\n\nconst windowCallbacks = new Set<WindowResizeHandler>()\n\nlet windowResizeHandler: VoidFunction | undefined\n\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const info = {\n            get width() {\n                return window.innerWidth\n            },\n            get height() {\n                return window.innerHeight\n            },\n        }\n\n        windowCallbacks.forEach((callback) => callback(info))\n    }\n\n    window.addEventListener(\"resize\", windowResizeHandler)\n}\n\nexport function resizeWindow(callback: WindowResizeHandler) {\n    windowCallbacks.add(callback)\n\n    if (!windowResizeHandler) createWindowResizeHandler()\n\n    return () => {\n        windowCallbacks.delete(callback)\n\n        if (\n            !windowCallbacks.size &&\n            typeof windowResizeHandler === \"function\"\n        ) {\n            window.removeEventListener(\"resize\", windowResizeHandler)\n            windowResizeHandler = undefined\n        }\n    }\n}\n","import { Edge, EdgeString, Intersection, ProgressIntersection } from \"../types\"\nimport { namedEdges, resolveEdge } from \"./edge\"\n\nconst defaultOffset: ProgressIntersection = [0, 0]\n\nexport function resolveOffset(\n    offset: Edge | Intersection | ProgressIntersection,\n    containerLength: number,\n    targetLength: number,\n    targetInset: number\n) {\n    let offsetDefinition: ProgressIntersection | [EdgeString, EdgeString] =\n        Array.isArray(offset) ? offset : defaultOffset\n\n    let targetPoint = 0\n    let containerPoint = 0\n\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset]\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim() as EdgeString\n\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \") as [EdgeString, EdgeString]\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset as keyof typeof namedEdges] ? offset : `0`]\n        }\n    }\n\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset)\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength)\n\n    return targetPoint - containerPoint\n}\n","import { isHTMLElement } from \"motion-dom\"\n\nexport function calcInset(element: Element, container: Element) {\n    const inset = { x: 0, y: 0 }\n\n    let current: Element | null = element\n    while (current && current !== container) {\n        if (isHTMLElement(current)) {\n            inset.x += current.offsetLeft\n            inset.y += current.offsetTop\n            current = current.offsetParent\n        } else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect()\n            current = current.parentElement!\n            const parentBoundingBox = current.getBoundingClientRect()\n            inset.x += svgBoundingBox.left - parentBoundingBox.left\n            inset.y += svgBoundingBox.top - parentBoundingBox.top\n        } else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox()\n            inset.x += x\n            inset.y += y\n\n            let svg: SVGElement | null = null\n            let parent: SVGElement = current.parentNode as SVGElement\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent\n                }\n                parent = current.parentNode as SVGElement\n            }\n            current = svg\n        } else {\n            break\n        }\n    }\n\n    return inset\n}\n","import { ProgressTimeline } from \"../animation/types\"\nimport { cancelFrame, frame } from \"../frameloop\"\n\ntype Update = (progress: number) => void\n\nexport function observeTimeline(update: Update, timeline: ProgressTimeline) {\n    let prevProgress: number\n\n    const onFrame = () => {\n        const { currentTime } = timeline\n        const percentage = currentTime === null ? 0 : currentTime.value\n        const progress = percentage / 100\n\n        if (prevProgress !== progress) {\n            update(progress)\n        }\n\n        prevProgress = progress\n    }\n\n    frame.preUpdate(onFrame, true)\n\n    return () => cancelFrame(onFrame)\n}\n","import { ElementOrSelector } from \"../utils/resolve-elements\"\nimport { resizeElement } from \"./handle-element\"\nimport { resizeWindow } from \"./handle-window\"\nimport { ResizeHandler, WindowResizeHandler } from \"./types\"\n\nexport function resize(onResize: WindowResizeHandler): VoidFunction\nexport function resize(\n    target: ElementOrSelector,\n    onResize: ResizeHandler<Element>\n): VoidFunction\nexport function resize(\n    a: WindowResizeHandler | ElementOrSelector,\n    b?: ResizeHandler<Element>\n) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b!)\n}\n","import { ProgressTimeline, supportsScrollTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"../track\"\nimport { ScrollOptionsWithDefaults } from \"../types\"\n\ndeclare global {\n    interface Window {\n        ScrollTimeline: ScrollTimeline\n    }\n}\n\ndeclare class ScrollTimeline implements ProgressTimeline {\n    constructor(options: ScrollOptions)\n\n    currentTime: null | { value: number }\n\n    cancel?: VoidFunction\n}\n\nconst timelineCache = new Map<\n    Element,\n    Map<Element | \"self\", { x?: ProgressTimeline; y?: ProgressTimeline }>\n>()\n\nfunction scrollTimelineFallback(options: ScrollOptionsWithDefaults) {\n    const currentTime = { value: 0 }\n\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[options.axis!].progress * 100\n    }, options)\n\n    return { currentTime, cancel }\n}\n\nexport function getTimeline({\n    source,\n    container,\n    ...options\n}: ScrollOptionsWithDefaults): ProgressTimeline {\n    const { axis } = options\n\n    if (source) container = source\n\n    const containerCache = timelineCache.get(container) ?? new Map()\n    timelineCache.set(container, containerCache)\n\n    const targetKey = options.target ?? \"self\"\n    const targetCache = containerCache.get(targetKey) ?? {}\n\n    const axisKey = axis + (options.offset ?? []).join(\",\")\n\n    if (!targetCache[axisKey]) {\n        targetCache[axisKey] =\n            !options.target && supportsScrollTimeline()\n                ? new ScrollTimeline({ source: container, axis } as any)\n                : scrollTimelineFallback({ container, ...options })\n    }\n\n    return targetCache[axisKey]!\n}\n","import { isSVGElement } from \"../utils/is-svg-element\"\nimport { ElementOrSelector, resolveElements } from \"../utils/resolve-elements\"\nimport { ResizeHandler } from \"./types\"\n\nconst resizeHandlers = new WeakMap<Element, Set<ResizeHandler<Element>>>()\n\nlet observer: ResizeObserver | undefined\n\nconst getSize =\n    (\n        borderBoxAxis: \"inline\" | \"block\",\n        svgAxis: \"width\" | \"height\",\n        htmlAxis: \"offsetWidth\" | \"offsetHeight\"\n    ) =>\n    (target: Element, borderBoxSize?: ReadonlyArray<ResizeObserverSize>) => {\n        if (borderBoxSize && borderBoxSize[0]) {\n            return borderBoxSize[0][\n                (borderBoxAxis + \"Size\") as keyof ResizeObserverSize\n            ]\n        } else if (isSVGElement(target) && \"getBBox\" in target) {\n            return (target as SVGGraphicsElement).getBBox()[svgAxis]\n        } else {\n            return (target as HTMLElement)[htmlAxis]\n        }\n    }\n\nconst getWidth = /*@__PURE__*/ getSize(\"inline\", \"width\", \"offsetWidth\")\nconst getHeight = /*@__PURE__*/ getSize(\"block\", \"height\", \"offsetHeight\")\n\nfunction notifyTarget({ target, borderBoxSize }: ResizeObserverEntry) {\n    resizeHandlers.get(target)?.forEach((handler) => {\n        handler(target, {\n            get width() {\n                return getWidth(target, borderBoxSize)\n            },\n            get height() {\n                return getHeight(target, borderBoxSize)\n            },\n        })\n    })\n}\n\nfunction notifyAll(entries: ResizeObserverEntry[]) {\n    entries.forEach(notifyTarget)\n}\n\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\") return\n\n    observer = new ResizeObserver(notifyAll)\n}\n\nexport function resizeElement(\n    target: ElementOrSelector,\n    handler: ResizeHandler<Element>\n) {\n    if (!observer) createResizeObserver()\n\n    const elements = resolveElements(target)\n\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element)\n\n        if (!elementHandlers) {\n            elementHandlers = new Set()\n            resizeHandlers.set(element, elementHandlers)\n        }\n\n        elementHandlers.add(handler)\n        observer?.observe(element)\n    })\n\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element)\n\n            elementHandlers?.delete(handler)\n\n            if (!elementHandlers?.size) {\n                observer?.unobserve(element)\n            }\n        })\n    }\n}\n","import { AnimationPlaybackControls, observeTimeline } from \"motion-dom\"\nimport { ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\nexport function attachToAnimation(\n    animation: AnimationPlaybackControls,\n    options: ScrollOptionsWithDefaults\n) {\n    const timeline = getTimeline(options)\n\n    return animation.attachTimeline({\n        timeline: options.target ? undefined : timeline,\n        observe: (valueAnimation) => {\n            valueAnimation.pause()\n\n            return observeTimeline((progress) => {\n                valueAnimation.time =\n                    valueAnimation.iterationDuration * progress\n            }, timeline)\n        },\n    })\n}\n","import { AnimationPlaybackControls } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { attachToAnimation } from \"./attach-animation\"\nimport { attachToFunction } from \"./attach-function\"\nimport { OnScroll, ScrollOptions } from \"./types\"\n\nexport function scroll(\n    onScroll: OnScroll | AnimationPlaybackControls,\n    {\n        axis = \"y\",\n        container = document.scrollingElement as Element,\n        ...options\n    }: ScrollOptions = {}\n): VoidFunction {\n    if (!container) return noop as VoidFunction\n\n    const optionsWithDefaults = { axis, container, ...options }\n\n    return typeof onScroll === \"function\"\n        ? attachToFunction(onScroll, optionsWithDefaults)\n        : attachToAnimation(onScroll, optionsWithDefaults)\n}\n","import { warnOnce } from \"motion-utils\"\nimport { updateScrollInfo } from \"./info\"\nimport { resolveOffsets } from \"./offsets/index\"\nimport {\n    OnScrollHandler,\n    OnScrollInfo,\n    ScrollInfo,\n    ScrollInfoOptions,\n} from \"./types\"\n\nfunction measure(\n    container: Element,\n    target: Element = container,\n    info: ScrollInfo\n) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0\n    info.y.targetOffset = 0\n    if (target !== container) {\n        let node = target as HTMLElement\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft\n            info.y.targetOffset += node.offsetTop\n            node = node.offsetParent as HTMLElement\n        }\n    }\n\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight\n    info.x.containerLength = container.clientWidth\n    info.y.containerLength = container.clientHeight\n\n    /**\n     * In development mode ensure scroll containers aren't position: static as this makes\n     * it difficult to measure their relative positions.\n     */\n    if (process.env.NODE_ENV !== \"production\") {\n        if (container && target && target !== container) {\n            warnOnce(\n                getComputedStyle(container).position !== \"static\",\n                \"Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.\"\n            )\n        }\n    }\n}\n\nexport function createOnScrollHandler(\n    element: Element,\n    onScroll: OnScrollInfo,\n    info: ScrollInfo,\n    options: ScrollInfoOptions = {}\n): OnScrollHandler {\n    return {\n        measure: (time) => {\n            measure(element, options.target, info)\n            updateScrollInfo(element, info, time)\n\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options)\n            }\n        },\n        notify: () => onScroll(info),\n    }\n}\n","import { progress, velocityPerSecond } from \"motion-utils\"\nimport { AxisScrollInfo, ScrollInfo } from \"./types\"\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50\n\nconst createAxisInfo = (): AxisScrollInfo => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n})\n\nexport const createScrollInfo = (): ScrollInfo => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n})\n\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n} as const\n\nfunction updateAxisInfo(\n    element: Element,\n    axisName: \"x\" | \"y\",\n    info: ScrollInfo,\n    time: number\n) {\n    const axis = info[axisName]\n    const { length, position } = keys[axisName]\n\n    const prev = axis.current\n    const prevTime = info.time\n\n    axis.current = element[`scroll${position}`]\n    axis.scrollLength = element[`scroll${length}`] - element[`client${length}`]\n\n    axis.offset.length = 0\n    axis.offset[0] = 0\n    axis.offset[1] = axis.scrollLength\n    axis.progress = progress(0, axis.scrollLength, axis.current)\n\n    const elapsed = time - prevTime\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed)\n}\n\nexport function updateScrollInfo(\n    element: Element,\n    info: ScrollInfo,\n    time: number\n) {\n    updateAxisInfo(element, \"x\", info, time)\n    updateAxisInfo(element, \"y\", info, time)\n    info.time = time\n}\n","import { cancelFrame, frame, frameData, resize, Process } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { createScrollInfo } from \"./info\"\nimport { createOnScrollHandler } from \"./on-scroll-handler\"\nimport { OnScrollHandler, OnScrollInfo, ScrollInfoOptions } from \"./types\"\n\nconst scrollListeners = new WeakMap<Element, VoidFunction>()\nconst resizeListeners = new WeakMap<Element, VoidFunction>()\nconst onScrollHandlers = new WeakMap<Element, Set<OnScrollHandler>>()\nconst scrollSize = new WeakMap<Element, { width: number; height: number }>()\nconst dimensionCheckProcesses = new WeakMap<Element, Process>()\n\nexport type ScrollTargets = Array<HTMLElement>\n\nconst getEventTarget = (element: Element) =>\n    element === document.scrollingElement ? window : element\n\nexport function scrollInfo(\n    onScroll: OnScrollInfo,\n    {\n        container = document.scrollingElement as Element,\n        trackContentSize = false,\n        ...options\n    }: ScrollInfoOptions = {}\n) {\n    if (!container) return noop as VoidFunction\n\n    let containerHandlers = onScrollHandlers.get(container)\n\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set()\n        onScrollHandlers.set(container, containerHandlers)\n    }\n\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo()\n    const containerHandler = createOnScrollHandler(\n        container,\n        onScroll,\n        info,\n        options\n    )\n    containerHandlers.add(containerHandler)\n\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers) {\n                handler.measure(frameData.timestamp)\n            }\n\n            frame.preUpdate(notifyAll)\n        }\n\n        const notifyAll = () => {\n            for (const handler of containerHandlers) {\n                handler.notify()\n            }\n        }\n\n        const listener = () => frame.read(measureAll)\n\n        scrollListeners.set(container, listener)\n\n        const target = getEventTarget(container)\n        window.addEventListener(\"resize\", listener, { passive: true })\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener))\n        }\n\n        target.addEventListener(\"scroll\", listener, { passive: true })\n\n        listener()\n    }\n\n    /**\n     * Enable content size tracking if requested and not already enabled.\n     */\n    if (trackContentSize && !dimensionCheckProcesses.has(container)) {\n        const listener = scrollListeners.get(container)!\n\n        // Store initial scroll dimensions (object is reused to avoid allocation)\n        const size = {\n            width: container.scrollWidth,\n            height: container.scrollHeight,\n        }\n        scrollSize.set(container, size)\n\n        // Add frame-based scroll dimension checking to detect content changes\n        const checkScrollDimensions: Process = () => {\n            const newWidth = container.scrollWidth\n            const newHeight = container.scrollHeight\n\n            if (size.width !== newWidth || size.height !== newHeight) {\n                listener()\n                size.width = newWidth\n                size.height = newHeight\n            }\n        }\n\n        // Schedule with keepAlive=true to run every frame\n        const dimensionCheckProcess = frame.read(checkScrollDimensions, true)\n        dimensionCheckProcesses.set(container, dimensionCheckProcess)\n    }\n\n    const listener = scrollListeners.get(container)!\n    frame.read(listener, false, true)\n\n    return () => {\n        cancelFrame(listener)\n\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container)\n        if (!currentHandlers) return\n\n        currentHandlers.delete(containerHandler)\n\n        if (currentHandlers.size) return\n\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container)\n        scrollListeners.delete(container)\n\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\n                \"scroll\",\n                scrollListener\n            )\n            resizeListeners.get(container)?.()\n            window.removeEventListener(\"resize\", scrollListener)\n        }\n\n        // Clean up scroll dimension checking\n        const dimensionCheckProcess = dimensionCheckProcesses.get(container)\n        if (dimensionCheckProcess) {\n            cancelFrame(dimensionCheckProcess)\n            dimensionCheckProcesses.delete(container)\n        }\n        scrollSize.delete(container)\n    }\n}\n","import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n","import { observeTimeline } from \"motion-dom\"\nimport { scrollInfo } from \"./track\"\nimport { OnScroll, OnScrollWithInfo, ScrollOptionsWithDefaults } from \"./types\"\nimport { getTimeline } from \"./utils/get-timeline\"\n\n/**\n * If the onScroll function has two arguments, it's expecting\n * more specific information about the scroll from scrollInfo.\n */\nfunction isOnScrollWithInfo(onScroll: OnScroll): onScroll is OnScrollWithInfo {\n    return onScroll.length === 2\n}\n\nexport function attachToFunction(\n    onScroll: OnScroll,\n    options: ScrollOptionsWithDefaults\n) {\n    if (isOnScrollWithInfo(onScroll)) {\n        return scrollInfo((info) => {\n            onScroll(info[options.axis!].progress, info)\n        }, options)\n    } else {\n        return observeTimeline(onScroll, getTimeline(options))\n    }\n}\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M15 3h6v6', key: '1q9fwt' }],\n  ['path', { d: 'm21 3-7 7', key: '1l2asr' }],\n  ['path', { d: 'm3 21 7-7', key: 'tjx5ai' }],\n  ['path', { d: 'M9 21H3v-6', key: 'wtvkvv' }],\n];\n\n/**\n * @component @name Maximize2\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTUgM2g2djYiIC8+CiAgPHBhdGggZD0ibTIxIDMtNyA3IiAvPgogIDxwYXRoIGQ9Im0zIDIxIDctNyIgLz4KICA8cGF0aCBkPSJNOSAyMUgzdi02IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/maximize-2\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Maximize2 = createLucideIcon('maximize-2', __iconNode);\n\nexport default Maximize2;\n","\"use client\"\n\nimport { motionValue } from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\nimport { RefObject, useCallback, useEffect, useRef } from \"react\"\nimport { scroll } from \"../render/dom/scroll\"\nimport { ScrollInfoOptions } from \"../render/dom/scroll/types\"\nimport { useConstant } from \"../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../utils/use-isomorphic-effect\"\n\nexport interface UseScrollOptions\n    extends Omit<ScrollInfoOptions, \"container\" | \"target\"> {\n    container?: RefObject<HTMLElement | null>\n    target?: RefObject<HTMLElement | null>\n}\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n})\n\nconst isRefPending = (ref?: RefObject<HTMLElement | null>) => {\n    if (!ref) return false\n    return !ref.current\n}\n\nexport function useScroll({\n    container,\n    target,\n    ...options\n}: UseScrollOptions = {}) {\n    const values = useConstant(createScrollMotionValues)\n    const scrollAnimation = useRef<VoidFunction | null>(null)\n    const needsStart = useRef(false)\n\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll(\n            (\n                _progress: number,\n                {\n                    x,\n                    y,\n                }: {\n                    x: { current: number; progress: number }\n                    y: { current: number; progress: number }\n                }\n            ) => {\n                values.scrollX.set(x.current)\n                values.scrollXProgress.set(x.progress)\n                values.scrollY.set(y.current)\n                values.scrollYProgress.set(y.progress)\n            },\n            {\n                ...options,\n                container: container?.current || undefined,\n                target: target?.current || undefined,\n            }\n        )\n\n        return () => {\n            scrollAnimation.current?.()\n        }\n    }, [container, target, JSON.stringify(options.offset)])\n\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false\n\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true\n            return\n        } else {\n            return start()\n        }\n    }, [start])\n\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(\n                !isRefPending(container),\n                \"Container ref is defined but not hydrated\",\n                \"use-scroll-ref\"\n            )\n            invariant(\n                !isRefPending(target),\n                \"Target ref is defined but not hydrated\",\n                \"use-scroll-ref\"\n            )\n            return start()\n        } else {\n            return\n        }\n    }, [start])\n\n    return values\n}\n"],"names":[],"mappings":"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","ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}